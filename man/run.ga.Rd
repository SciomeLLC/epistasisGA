% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run.ga.R
\name{run.ga}
\alias{run.ga}
\title{A function to run a genetic algorithm to detect multi-SNP effects in case-parent triad studies.}
\usage{
run.ga(
  data.list,
  n.chromosomes,
  chromosome.size,
  results.dir,
  cluster.type,
  registryargs = list(file.dir = NA, seed = 1500),
  resources = list(),
  cluster.template = NULL,
  n.workers = min(detectCores() - 2, n.islands/island.cluster.size),
  n.chunks = NULL,
  n.different.snps.weight = 2,
  n.both.one.weight = 1,
  weight.function.int = 2,
  generations = 500,
  gen.same.fitness = 50,
  tol = 10^-6,
  n.top.chroms = 100,
  initial.sample.duplicates = FALSE,
  snp.sampling.type = "chisq",
  crossover.prop = 0.8,
  n.islands = 1000,
  island.cluster.size = 4,
  migration.generations = 50,
  n.migrations = 20,
  n.case.high.risk.thresh = 20,
  outlier.sd = 2.5
)
}
\arguments{
\item{data.list}{The output list from \code{preprocess.genetic.data}.}

\item{n.chromosomes}{An integer specifying the number of chromosomes to use in the GA.}

\item{chromosome.size}{An integer specifying the number of SNPs on each chromosome.}

\item{results.dir}{The directory to which island results will be saved.}

\item{cluster.type}{A character string indicating the type of cluster on which to evolve solutions in parallel.
Supported options are interactive, socket, multicore, sge, slurm, lsf, openlava, or torque. See the documentation for package batchtools for more information.}

\item{registryargs}{A list of the arguments to be provided to \code{batchtools::makeRegistry}.}

\item{resources}{A named list of key-value pairs to be substituted into the template file. Options available are specified in \code{batchtools::submitJobs}.}

\item{cluster.template}{A character string of the path to the template file required for the cluster specified in \code{cluster.type}.
Defaults to NULL. Required for options sge, slurm, lsf, openlava and torque of argument \code{cluster.type}.}

\item{n.workers}{An integer indicating the number of workers for the cluster specified in \code{cluster.type}, if socket or multicore.
Defaults to \code{parallel::detectCores - 2}.}

\item{n.chunks}{An integer specifying the number of chunks jobs running island clusters should be split into when dispatching jobs using \code{batchtools}.
For multicore or socket \code{cluster.type}, this defaults to \code{n.workers}, resulting in the total number of island cluster jobs
(equal to \code{n.islands}\\\code{island.cluster.size}) being split into \code{n.chunks} chunks.
All job chunks then run in parallel, with jobs within a chunk running sequentially. For other cluster types, this defaults to 1 chunk, with the expectation
that users of HPC clusters that support array jobs specify \code{chunks.as.arrayjobs = TRUE} in argument \code{resources}. For those users, the setup will
submit an array of \code{n.islands}\\\code{island.cluster.size} jobs to the cluster. For HPC clusters that do not support array jobs, the default setting
should not be used. See \code{batchtools::submitJobs} for more information on job chunking.}

\item{n.different.snps.weight}{The number by which the number of different SNPs between a case and complement or unaffected sibling
is multiplied in computing the family weights. Defaults to 2.}

\item{n.both.one.weight}{The number by which the number of SNPs equal to 1 in both the case and complement or unaffected sibling
is multiplied in computing the family weights. Defaults to 1.}

\item{weight.function.int}{An integer used to assign family weights. Specifically, we use \code{weight.function.int} in a  function that takes the weighted sum
of the number of different SNPs and SNPs both equal to one as an argument, denoted as x, and returns a family weight equal to \code{weight.function.int}^x. Defaults to 2.}

\item{generations}{The maximum number of generations for which the GA will run. Defaults to 500.}

\item{gen.same.fitness}{The number of consecutive generations with the same fitness score required for algorithm termination. Defaults to 50.}

\item{tol}{The maximum absolute pairwise difference among the top fitness scores from the previous \code{gen.same.fitness} generations
considered to be sufficient to stop the algorithm.}

\item{n.top.chroms}{The number of top scoring chromosomes according to fitness score to return. Defaults to 100.}

\item{initial.sample.duplicates}{A logical indicating whether the same SNP can appear in more than one chromosome in the initial sample of chromosomes
(the same SNP may appear in more than one chromosome thereafter, regardless). Default to FALSE.}

\item{snp.sampling.type}{A string indicating how SNPs are to be sampled for mutations. Options are 'chisq' or 'random'. The 'chisq' option takes
into account the marginal association between a SNP and disease status, with larger marginal associations corresponding to higher sampling probabilities.
The 'random'  option gives each SNP the same sampling probability regardless of marginal association. Defaults to 'chisq'.}

\item{crossover.prop}{A numeric between 0 and 1 indicating the proportion of chromosomes to be subjected to cross over.
The remaining proportion will be mutated. Defaults to 0.8.}

\item{n.islands}{An integer indicating the number of islands to be used in the GA. Defaults to 1000.}

\item{island.cluster.size}{An integer specifying the number of islands in a given cluster. Must evenly divide \code{n.islands} and defaults to 4.
More specifically, under the default settings, the 1000 \code{n.islands} are split into 250 distinct clusters each containing 4 islands (\code{island.cluster.size}).
Within a cluster, migrations of top chromosomes from one cluster island to another are periodically permitted (controlled by \code{migration.generations}), and distinct
clusters evolve completely independently.}

\item{migration.generations}{An integer equal to the number of generations between migrations among islands of a distinct cluster.
Argument \code{generations} must be an integer multiple of this value. Defaults to 50.}

\item{n.migrations}{The number of chromosomes that migrate among islands. This value must be less than \code{n.chromosomes} and greater than 0, defaulting to 20.}

\item{n.case.high.risk.thresh}{The number of cases with the provisional high risk set required to check for recessive patterns of allele inheritance. Defaults to 20.}

\item{outlier.sd}{The number of standard deviations from the mean allele count used to determine whether recessive allele coding is appropriate
for a given SNP. See the GADGET paper for specific details on the implementation of this argument.}
}
\value{
For each island, a list of two elements will be written to \code{results.dir}:
\describe{
 \item{top.chromosome.results}{A data.table of the top \code{n.top.chroms scoring chromosomes}, their fitness scores, their difference vectors,
and the number of risk alleles required for each chromosome SNP for a case or complement to be classified as having the provisional risk set.
See the package vignette for an example and the documentation for \code{chrom.fitness.score} for additional details.}
 \item{n.generations}{The total number of generations run.}
}
}
\description{
This function runs a genetic algorithm to detect multi-SNP effects in case-parent triad studies.
}
\examples{

data(case)
data(dad)
data(mom)
library(Matrix)
block.ld.mat <- as.matrix(bdiag(list(matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25))))
pp.list <- preprocess.genetic.data(case[, 1:10], father.genetic.data = dad[ , 1:10],
                               mother.genetic.data = mom[ , 1:10],
                               block.ld.mat = block.ld.mat[1:10, 1:10])
run.ga(pp.list, n.chromosomes = 4, chromosome.size = 3, results.dir = 'tmp',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)

unlink('tmp', recursive = TRUE)
unlink('tmp_reg', recursive = TRUE)

}
