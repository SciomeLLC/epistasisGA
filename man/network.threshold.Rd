% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/network.threshold.R
\name{network.threshold}
\alias{network.threshold}
\title{A function to identify a SNPs to be included in a network plot}
\usage{
network.threshold(observed.edges, permutation.edges.list, desired.rFDR = 0.01)
}
\arguments{
\item{observed.edges}{The data.table output from \code{compute.edge.scores} run on the observed data.}

\item{permutation.edges.list}{A list of data.tables, each containing the result for \code{compute.edge.scores} run on the results of a permutation dataset.}

\item{desired.rFDR}{The desired rFDR threshold. Defaults to 0.01.}
}
\value{
a list containing the following:
\describe{
 \item{network.edges}{A data.table of network edges, where the first two columns represent SNPs and the third column (edge.score)
 is the edge score of a chromosome containing those SNPs, where the edge.scores exceed a threshold, t, such that the achieved rFDR
 is not greater than \code{desired.rFDR}.}
 \item{rFDR}{The achieved rFDR.}
 \item{t}{The threshold edge.score, t, corresponding to the achieved rFDR.}
}
}
\description{
This function compares the edge scores generated by \code{compute.edge.scores} in the observed data to a list of permuted
null datasets and identifies SNPs to be included in a network plot. Specifically, it finds a threshold edge.score, t, such that the mean
fraction of edge scores exceeding t over all permuted datasets divided by the fraction of edge scores exceeding t in the observed data is
not greater than a desired threshold. We refer to this ratio as the rFDR.
}
\examples{
data(case)
data(dad)
data(mom)
data(snp.annotations)
library(Matrix)
chrom.mat <- as.matrix(bdiag(list(matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25))))

pp.list <- preprocess.genetic.data(case[, 1:10], father.genetic.data = dad[ , 1:10],
                               mother.genetic.data = mom[ , 1:10],
                               chrom.mat = chrom.mat[ , 1:10])
## run GA for observed data

run.ga(pp.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'tmp_3',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 combined.res3 <- combine.islands('tmp_3', snp.annotations[ 1:10, ], pp.list)
 unlink('tmp_reg', recursive = TRUE)

## create three permuted datasets
set.seed(1400)
perm.data.list <- permute.dataset(case[ , 1:10],
                                  father.genetic.data = dad[ , 1:10],
                                  mother.genetic.data = mom[ , 1:10],
                                  n.permutations = 3)

## pre-process permuted data
p1.list <- preprocess.genetic.data(perm.data.list[['permutation1']]$case,
                                   complement.genetic.data = perm.data.list[['permutation1']]$comp,
                                   chrom.mat = chrom.mat[ , 1:10])

p2.list <- preprocess.genetic.data(perm.data.list[['permutation2']]$case,
                                   complement.genetic.data = perm.data.list[['permutation2']]$comp,
                                   chrom.mat = chrom.mat[ , 1:10])

p3.list <- preprocess.genetic.data(perm.data.list[['permutation3']]$case,
                                   complement.genetic.data = perm.data.list[['permutation3']]$comp,
                                   chrom.mat = chrom.mat[ , 1:10])

## run GA for permuted data

run.ga(p1.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'p1_tmp_3',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 p1.combined.res3 <- combine.islands('p1_tmp_3', snp.annotations[ 1:10, ], p1.list)
 unlink('tmp_reg', recursive = TRUE)

run.ga(p2.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'p2_tmp_3',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 p2.combined.res3 <- combine.islands('p2_tmp_3', snp.annotations[ 1:10, ], p2.list)
 unlink('tmp_reg', recursive = TRUE)

run.ga(p3.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'p3_tmp_3',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 p3.combined.res3 <- combine.islands('p3_tmp_3', snp.annotations[ 1:10, ], p3.list)
 unlink('tmp_reg', recursive = TRUE)

 #get edge scores
 obs.edge.scores <- compute.edge.scores(combined.res3$unique.results)
 perm.edge.scores <- lapply(list(p1.combined.res3$unique.results,
                        p2.combined.res3$unique.results,
                        p3.combined.res3$unique.results), compute.edge.scores)

 ## get thresholded edge scores
 threshold.res <- network.threshold(obs.edge.scores,
                   perm.edge.scores)

 ## plot thresholded network
 network.plot(threshold.res)

 lapply(c('tmp_3' ,'p1_tmp_3', 'p2_tmp_3', 'p3_tmp_3'), unlink, recursive = TRUE)

}
