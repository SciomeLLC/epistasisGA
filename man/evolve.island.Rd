% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evolve.island.R
\name{evolve.island}
\alias{evolve.island}
\title{A function to run a genetic algorithm for a specific island for a given number of generations}
\usage{
evolve.island(
  n.migrations = 20,
  case.genetic.data,
  complement.genetic.data,
  case.comp.different,
  case.minus.comp,
  both.one.mat,
  chrom.mat,
  n.chromosomes,
  n.candidate.snps,
  chromosome.size,
  start.generation,
  snp.chisq,
  original.col.numbers,
  all.converged = FALSE,
  n.different.snps.weight = 2,
  n.both.one.weight = 1,
  weight.function = function(x) 2^x,
  migration.interval = 50,
  gen.same.fitness = 50,
  max.generations = 500,
  tol = 10^-6,
  n.top.chroms = 100,
  initial.sample.duplicates = FALSE,
  snp.sampling.type = "chisq",
  crossover.prop = 0.8,
  chromosome.list = NULL,
  fitness.score.mat = NULL,
  top.fitness = NULL,
  last.gens.equal = NULL,
  top.generation.chromosome = NULL,
  chromosome.mat.list = NULL,
  sum.dif.vec.list = NULL,
  inherit.vec.list = NULL,
  n.case.high.risk.thresh = 20,
  outlier.sd = 2.5
)
}
\arguments{
\item{n.migrations}{The number of chromosomes that migrate among islands. This value must be less than \code{n.chromosomes} and greater than 0, defaulting to 20.}

\item{case.genetic.data}{The genetic data of the disease affected children from case-parent trios. Columns are SNPs, and rows are individuals.}

\item{complement.genetic.data}{A genetic dataset from the complements of the cases, where
\code{complement.genetic.data} = mother SNP counts + father SNP counts - case SNP counts.
Columns are SNPs, rows are families.}

\item{case.comp.different}{A data frame or matrix indicating \code{case.genetic.data} != \code{complement.genetic.data},
where rows correspond to individuals and columns correspond to snps.}

\item{case.minus.comp}{A matrix equal to \code{case.genetic.data} - \code{complement genetic data}.}

\item{both.one.mat}{A matrix whose elements indicate whether both the case and complement have one copy of the minor allele,
equal to \code{case.genetic.data == 1 & complement.genetic.data == 1}.}

\item{chrom.mat}{A logical matrix indicating whether the SNPs in \code{case.genetic.data} are located on the same biological chromosome.}

\item{n.chromosomes}{An integer specifying the number of chromosomes to use in the GA.}

\item{n.candidate.snps}{A scalar indicating the number eligible SNPs in the input data, after filtering out low MAF SNPs.}

\item{chromosome.size}{An integer specifying the number of SNPs on each chromosome.}

\item{start.generation}{The generation at which this function should begin. If 1, a random set of chromosomes will be initialized.
Otherwise the argument \code{chromosome.list} will be used.}

\item{snp.chisq}{A vector of chi-square statistics corresponding to marginal SNP-disease associations for each column in \code{case.genetic.data}.}

\item{original.col.numbers}{A vector of integers indicating the original column number of each SNP in \code{case.genetic.data},
needed due to removal of low frequency SNPs in \code{preprocess.genetic.data}.}

\item{all.converged}{A logical indicating whether each island in the cluster has converged to a solution.}

\item{n.different.snps.weight}{The number by which the number of different SNPs between a case and complement is multiplied in computing the family weights. Defaults to 2.}

\item{n.both.one.weight}{The number by which the number of SNPs equal to 1 in both the case and complement is multiplied in computing the family weights. Defaults to 1.}

\item{weight.function}{A function that takes the weighted sum of the number of different SNPs and SNPs both equal to one as an argument, denoted as x,
and returns a family weight. Defaults to 2^x.}

\item{migration.interval}{The interval of generations for which the GA will run prior to migration of top chromosomes among islands in a cluster. Defaults to 50.
In other words, top chromosomes will migrate among cluster islands every \code{migration.interval} generations.}

\item{gen.same.fitness}{The number of consecutive generations with the same fitness score required for algorithm termination. Defaults to 50.}

\item{max.generations}{The maximum number of generations for which the GA will run. Defaults to 500.}

\item{tol}{The maximum absolute pairwise difference among the top fitness scores from the previous \code{gen.same.fitness} generations
considered to be sufficient to stop the algorithm.}

\item{n.top.chroms}{The number of top scoring chromosomes according to fitness score to return. Defaults to 100.}

\item{initial.sample.duplicates}{A logical indicating whether the same SNP can appear in more than one chromosome in the initial sample of chromosomes
(the same SNP may appear in more than one chromosome thereafter, regardless). Default to FALSE.}

\item{snp.sampling.type}{A string indicating how SNPs are to be sampled for mutations. Options are 'chisq' or 'random'. The 'chisq' option takes
into account the marginal association between a SNP and disease status, with larger marginal associations corresponding to higher sampling probabilities.
The 'random'  option gives each SNP the same sampling probability regardless of marginal association. Defaults to 'chisq'.}

\item{crossover.prop}{A numeric between 0 and 1 indicating the proportion of chromosomes to be subjected to cross over.
The remaining proportion will be mutated. Defaults to 0.8.}

\item{chromosome.list}{A list of input chromosomes which the genetic algorithm will use as a starting population.}

\item{fitness.score.mat}{A matrix of fitness scores from previous generations in island evolution.}

\item{top.fitness}{A vector of top fitness scores from previous generations.}

\item{last.gens.equal}{A logical indicating whether the last \code{gen.same.fitness} generations of the algorithm all produced the same top fitness score.}

\item{top.generation.chromosome}{A list of top chromosomes from previous generations.}

\item{chromosome.mat.list}{A list of matrices containing all chromosomes from previous generations.}

\item{sum.dif.vec.list}{A list of matrices containing the sum of differences vectors for chromosomes in previous generations.}

\item{inherit.vec.list}{A list of matrices containing the proposed mode of inheritance for SNPs in chromosomes from previous generations.}

\item{n.case.high.risk.thresh}{The number of cases with the provisional high risk set required to check for recessive patterns of allele inheritance.}

\item{outlier.sd}{The number of standard deviations from the mean allele count used to determine whether recessive allele coding is appropriate
for a given SNP. See the GADGET paper for specific details on the implementation of this argument.}
}
\value{
If the algorithm has not converged, a list containing the following:
\describe{
 \item{migrations}{A list of chromosomes that will migrate to another island in the cluster.}
 \item{chromosome.list}{A list of chromosomes that will remain the island after migrations.}
 \item{fitness.score.mat}{A matrix of fitness scores for each chromosome across generations.}
 \item{top.fitness}{A vector of the top fitness scores across generations.}
 \item{last.gens.equal}{A logical indicating whether the last \code{gen.same.fitness} generations of the algorithm all produced the same top fitness score.}
 \item{top.generation.chromosome}{A list of the top scoring chromosome for the previous generations.}
 \item{chromosome.mat.list}{A list of all of the chromosomes examined in previous generations.}
 \item{sum.dif.vec.list}{A list of data.tables containing the sum of the difference vectors for all examined chromosomes.}
 \item{inherit.vec.list}{A list of data.tables containing the proposed mode of inheritance for SNPs in chromosomes from previous generations.}
 \item{generation}{An integer corresponding to the current generation of the genetic algorithm.}
}
If the algorithm converges, a list containing the following:
\describe{
 \item{top.chromosome.results}{A data.table of the top \code{n.top.chroms scoring chromosomes}, their fitness scores, their difference vectors,
and whether each SNP in the provisional risk set appears to exhibit a dominant or recessive pattern of inheritance.}
 \item{n.generations}{The total number of generations run.}
}
}
\description{
This function runs a genetic algorithm for a specific island for a given number of generations.
This function should not be used independently, it is only intended for use in \code{run.ga}.
}
\examples{

set.seed(10)
data(case)
data(dad)
data(mom)
library(Matrix)
chrom.mat <- as.matrix(bdiag(list(matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25))))
data.list <- preprocess.genetic.data(case[, 1:10], father.genetic.data = dad[ , 1:10],
                               mother.genetic.data = mom[ , 1:10],
                               chrom.mat = chrom.mat[ , 1:10])

 case.genetic.data <- data.list$case.genetic.data
 complement.genetic.data <- data.list$complement.genetic.data
 original.col.numbers <- data.list$original.col.numbers
 chisq.stats <- data.list$chisq.stats
 chrom.mat <- data.list$chrom.mat
 case.minus.comp <- sign(as.matrix(case.genetic.data - complement.genetic.data))
 case.comp.different <- case.minus.comp != 0
 both.one.mat <- complement.genetic.data == 1 & case.genetic.data == 1
 snp.chisq <- sqrt(chisq.stats)
 ex.island <- evolve.island(n.migrations = 2, case.genetic.data = case.genetic.data,
                   complement.genetic.data = complement.genetic.data,
                   case.comp.different = case.comp.different,
                   case.minus.comp = case.minus.comp, both.one.mat = both.one.mat,
                   chrom.mat = chrom.mat, n.chromosomes = 10,
                   n.candidate.snps = ncol(case.genetic.data),
                   chromosome.size = 3, start.generation = 1,
                   snp.chisq = snp.chisq,
                   original.col.numbers = original.col.numbers,
                   migration.interval = 5, max.generations = 10)


}
