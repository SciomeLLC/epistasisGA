% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evolve.island.R
\name{evolve.island}
\alias{evolve.island}
\title{A function to evolve a genetic algorithm for a specific island for a given number of generations}
\usage{
evolve.island(
  n.migrations = 20,
  case.genetic.data,
  complement.genetic.data,
  case.comp.different,
  case.minus.comp,
  both.one.mat,
  chrom.mat,
  n.chromosomes,
  n.candidate.snps,
  chromosome.size,
  start.generation,
  snp.chisq,
  original.col.numbers,
  all.converged = FALSE,
  n.different.snps.weight = 2,
  n.both.one.weight = 1,
  weight.function = function(x) 2^x,
  migration.interval = 50,
  gen.same.fitness = 50,
  max.generations = 500,
  tol = 10^-6,
  n.top.chroms = 100,
  initial.sample.duplicates = FALSE,
  snp.sampling.type = "chisq",
  crossover.prop = 0.8,
  chromosome.list = NULL,
  fitness.score.mat = NULL,
  top.fitness = NULL,
  last.gens.equal = NULL,
  top.generation.chromosome = NULL,
  chromosome.mat.list = NULL,
  sum.dif.vec.list = NULL,
  n.case.high.risk.thresh = 20
)
}
\arguments{
\item{n.migrations}{The number of chromosomes that migrate among islands. This value must be less than \code{n.chromosomes}.}

\item{case.genetic.data}{A genetic dataset from cases (for a dichotomous trait). Columns are snps, and rows are individuals.}

\item{complement.genetic.data}{A genetic dataset from the complements of the cases, where \code{complement.genetic.data} = mother snp counts + father snp counts - case snp counts. Columns are snps, rows are families. If not specified, \code{father.genetic.data} and \code{mother.genetic.data} must be specified.}

\item{case.comp.different}{a data frame or matrix indicating case genetic data != complement genetic data, where rows correspond to individuals and columns correspond to snps.}

\item{case.minus.comp}{A matrix equal to \code{case.genetic.data - complement genetic data}.}

\item{both.one.mat}{A matrix whose elements indicate whether both the case and complement have one copy of the alternate allele, equal to (case.genetic.data == 1 & complement.genetic.data == 1).}

\item{chrom.mat}{A logical matrix indicating whether the snps in \code{case.genetic.data} belong to the same chromosome.}

\item{n.chromosomes}{A scalar indicating the number of candidate collections of snps to use in the GA.}

\item{n.candidate.snps}{A scalar indicating the number eligible snps in the input data, after filtering out low MAF SNPs.}

\item{chromosome.size}{The number of snps within each candidate solution.}

\item{start.generation}{The generation at which this function should begin. If 1, a random set of chromosomes will be initialized. Otherwise the argument \code{chromosome.list} will be used.}

\item{snp.chisq}{A vector of chi-square statistics, corresponding to tests of association between the column snp in \code{case.genetic.data} and disease status.}

\item{original.col.numbers}{A vector of integers indicating the original column number of each snp in \code{case.genetic.data}, needed due to removal of low frequency snps in \code{preprocess.genetic.data}.}

\item{all.converged}{A logical indicating whether all islands have previously converged to a solution.}

\item{n.different.snps.weight}{The number by which the number different snps between case and control is multiplied in computing the family weights. Defaults to 2.}

\item{n.both.one.weight}{The number by which the number of different snps equal to 1 in both case and control is multiplied in computing the family weights. Defaults to 1.}

\item{weight.function}{A function that takes the weighted sum of the number of different snps and snps both equal to one as an argument, and returns a family weight. Defaults to the identity function.}

\item{migration.interval}{The interval of generations for which the GA will run prior to migration of chromosomes among islands in a cluster. Defaults to 50.}

\item{gen.same.fitness}{The number of consecutive generations with the same fitness score required for algorithm termination.}

\item{max.generations}{The total allowable number of generations. Defaults to 500.}

\item{tol}{The maximum absolute pairwise difference among the top fitness scores from the previous 500 generations considered to be sufficient to stop producing new generations.}

\item{n.top.chroms}{The number of top scoring chromosomes, according to fitness score, to return.}

\item{initial.sample.duplicates}{A logical indicating whether the same snp can appear in more than one chromosome in the initial sample of chromosomes (the same snp may appear in more than one chromosome thereafter, regardless). Default to F.}

\item{snp.sampling.type}{A string indicating how snps are to be sampled for mutations. Options are 'chisq' or 'random'. Defaults to 'chisq'.}

\item{crossover.prop}{A numeric between 0 and 1 indicating the proportion of chromosomes to be subjected to cross over. The remaining proportion will be mutated. Defaults to 0.8.}

\item{chromosome.list}{A list of chromosomes on which the genetic algorithm will start.}

\item{fitness.score.mat}{A matrix of fitness scores, from previous generations in island evolution.}

\item{top.fitness}{A vector of top fitness scores from previous generations.}

\item{last.gens.equal}{A logical indicating whether the last generations of the algorithm all produced the same top chromosome.}

\item{top.generation.chromosome}{A list of top chromosomes from previous generations.}

\item{chromosome.mat.list}{A list of matrices containing all chromosomes from previous generations.}

\item{sum.dif.vec.list}{A list of matrices containing the sum of differences vectors for chromosomes in previous generations.}

\item{n.case.high.risk.thresh}{The number of cases with the provisional high risk set required to check for recessive patterns of allele inheritance.}
}
\value{
A list of nine elements \code{migrations}, \code{chromosome.list}, \code{fitness.score.mat},
        \code{top.fitness}, \code{last.gens.equal}, \code{top.generation.chromosome}, \code{chromosome.mat.list},
        \code{sum.dif.vec.list}, and \code{generation}.
}
\description{
This function evolves a genetic algorithm for a given number of generations. This function should not be used independently, it is only intended for use in \code{run.ga}.
}
\examples{

data(case)
data(dad)
data(mom)
library(Matrix)
chrom.mat <- as.matrix(bdiag(list(matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25))))
data.list <- preprocess.genetic.data(case[, 1:10], father.genetic.data = dad[ , 1:10],
                               mother.genetic.data = mom[ , 1:10],
                               chrom.mat = chrom.mat[ , 1:10])

 case.genetic.data <- data.list$case.genetic.data
 complement.genetic.data <- data.list$complement.genetic.data
 original.col.numbers <- data.list$original.col.numbers
 chisq.stats <- data.list$chisq.stats
 chrom.mat <- data.list$chrom.mat
 case.minus.comp <- sign(as.matrix(case.genetic.data - complement.genetic.data))
 case.comp.different <- case.minus.comp != 0
 both.one.mat <- complement.genetic.data == 1 & case.genetic.data == 1
 snp.chisq <- sqrt(chisq.stats)
 ex.island <- evolve.island(n.migrations = 2, case.genetic.data = case.genetic.data,
                   complement.genetic.data = complement.genetic.data,
                   case.comp.different = case.comp.different,
                   case.minus.comp = case.minus.comp, both.one.mat = both.one.mat,
                   chrom.mat = chrom.mat, n.chromosomes = 10,
                   n.candidate.snps = ncol(case.genetic.data),
                   chromosome.size = 3, start.generation = 1,
                   snp.chisq = snp.chisq,
                   original.col.numbers = original.col.numbers,
                   migration.interval = 5, max.generations = 10)


}
