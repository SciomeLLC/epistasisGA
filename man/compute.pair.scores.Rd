% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute.pair.scores.R
\name{compute.pair.scores}
\alias{compute.pair.scores}
\title{A function to compute SNP-pair scores for network plots of results.}
\usage{
compute.pair.scores(
  results.list,
  pp.list,
  n.top.chroms = 50,
  score.type = "logsum",
  pval.thresh = 0.05,
  n.permutes = 10000,
  n.different.snps.weight = 2,
  n.both.one.weight = 1,
  weight.function.int = 2,
  recessive.ref.prop = 0.75,
  recode.test.stat = 1.64,
  dif.coding = TRUE,
  bp.param = bpparam()
)
}
\arguments{
\item{results.list}{A list of length d, where d is the number of chromosome sizes to be included in the network plot.
Each element of the list must be a data.table from \code{combine.islands} for a given chromosome size.
Each data.table in the list should be subset to the top \code{n.top.scores} scores,
otherwise an error will be returned.}

\item{pp.list}{The list output by \code{preprocess.genetic.data} run on the observed data.}

\item{n.top.chroms}{The number of top scoring chromosomes to be used in calculating the edge.scores. Defaults to 50.}

\item{score.type}{A character string specifying the method for aggregating SNP-pair scores across chromosome sizes. Options are
'max', 'sum', or 'logsum', defaulting to "logsum". For a given SNP-pair, it's graphical score will be the \code{score.type} of all
graphical scores of chromosomes containing that pair across chromosome sizes. The choice of 'logsum' rather than 'sum'
may be useful in cases where there are multiple risk-sets, and one is found much more frequently. However, it may be of interest to examine
plots using both \code{score.type} approaches. Note that "logsum" is actually the log of one plus the sum of the SNP-pair scores to avoid nodes or
edges having negative weights.}

\item{pval.thresh}{A numeric value between 0 and 1 specifying the epistasis test p-value threshold for a
chromosome to contribute to the network. Any chromosomes with epistasis p-value greater than \code{pval.thresh}
will not contribute to network plots. The argument defaults to 0.05.}

\item{n.permutes}{The number of permutations on which to base the epistasis tests. Defaults to 10000.}

\item{n.different.snps.weight}{The number by which the number of different SNPs between a case and complement/unaffected sibling
is multiplied in computing the family weights. Defaults to 2.}

\item{n.both.one.weight}{The number by which the number of SNPs equal to 1 in both the case and complement/unaffected sibling
is multiplied in computing the family weights. Defaults to 1.}

\item{weight.function.int}{An integer used to assign family weights. Specifically, we use \code{weight.function.int} in a function that takes the weighted sum
of the number of different SNPs and SNPs both equal to one as an argument, denoted as x, and
returns a family weight equal to \code{weight.function.int}^x. Defaults to 2.}

\item{recessive.ref.prop}{The proportion to which the observed proportion of informative cases with the provisional risk genotype(s) will be compared
to determine whether to recode the SNP as recessive. Defaults to 0.75.}

\item{recode.test.stat}{For a given SNP, the minimum test statistic required to recode and recompute the fitness score using recessive coding. Defaults to 1.64.
See the GADGETS paper for specific details.}

\item{dif.coding}{A logical indicating whether, for a given SNP, the case - complement genotype difference should
be coded as the sign of the difference (defaulting to true) or the raw difference.}

\item{bp.param}{The BPPARAM argument to be passed to bplapply. See \code{BiocParallel::bplapply} for more details.}
}
\value{
A data.table where the first four columns represent SNPs and the fifth column (edge.score)
is the graphical SNP-pair score.
}
\description{
This function returns a data.table of graphical SNP-pair scores for use in network plots of GADGETS results.
}
\examples{

data(case)
data(dad)
data(mom)
data(snp.annotations)
library(Matrix)
set.seed(1400)
block.ld.mat <- as.matrix(bdiag(list(matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25))))

#preprocess data
target.snps <- c(1:3, 30:32, 60:62, 85)
pp.list <- preprocess.genetic.data(case[, target.snps], father.genetic.data = dad[ , target.snps],
                               mother.genetic.data = mom[ , target.snps],
                               block.ld.mat = block.ld.mat[target.snps , target.snps])
## run GA for observed data

#observed data chromosome size 2
run.gadgets(pp.list, n.chromosomes = 5, chromosome.size = 2, results.dir = 'tmp_2',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1,
       n.migrations = 0)
 combined.res2 <- combine.islands('tmp_2', snp.annotations[ target.snps, ], pp.list, 2)
 unlink('tmp_reg', recursive = TRUE)

 #observed data chromosome size 3
 run.gadgets(pp.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'tmp_3',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1,
       n.migrations = 0)
 combined.res3 <- combine.islands('tmp_3', snp.annotations[ target.snps, ], pp.list, 2)
 unlink('tmp_reg', recursive = TRUE)

 ## create list of results

 final.results <- list(combined.res2[1:3, ], combined.res3[1:3, ])

 ## compute edge scores
 edge.dt <- compute.pair.scores(final.results, pp.list, 3, pval.thresh = 1)

 lapply(c('tmp_2', 'tmp_3'), unlink, recursive = TRUE)

}
