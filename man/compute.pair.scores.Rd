% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute.pair.scores.R
\name{compute.pair.scores}
\alias{compute.pair.scores}
\title{A function to compute SNP-pair scores for network plots of results.}
\usage{
compute.pair.scores(
  results.list,
  pp.list,
  n.top.chroms = 50,
  score.type = "logsum",
  epi.test.permutes = 100,
  bp.param = SerialParam(),
  pval.thresh = 0.05
)
}
\arguments{
\item{results.list}{A list of length d, where d is the number of chromosome sizes to be included in the network plot.
Each element of the list must be a data.table from \code{combine.islands} for a given chromosome size.
Each data.table in the list should be subset to the top \code{n.top.scores} scores,
otherwise an error will be returned.}

\item{pp.list}{The list output by \code{preprocess.genetic.data} run on the observed data.}

\item{n.top.chroms}{The number of top scoring chromosomes to be used in calculating the edge.scores. Defaults to 50.}

\item{score.type}{A character string specifying the method for aggregating SNP-pair scores across chromosome sizes. Options are
'max', 'sum', or 'logsum', defaulting to "logsum". For a given SNP-pair, it's graphical score will be the \code{score.type} of all
graphical scores of chromosomes containing that pair across chromosome sizes. The choice of 'logsum' rather than 'sum'
may be useful in cases where there are multiple risk-sets, and one is found much more frequently. However, it may be of interest to examine
plots using both \code{score.type} approaches. Note that "logsum" is actually the log of one plus the sum of the SNP-pair scores to avoid nodes or
edges having negative weights.}

\item{epi.test.permutes}{The number of permutes used to compute the epistasis test p-values. Defaults to 100.}

\item{bp.param}{The \code{bp.param} argument to be passed to \code{run.epi.test}.
If using a cluster computer, this parameter needs to be set with care. See \code{BiocParallel::bplapply} for more details}

\item{pval.thresh}{A numeric value between 0 and 1 specifying the epistasis test p-value threshold for a
chromosome to contribute to the network. Any chromosomes with epistasis p-value greater than \code{pval.thresh}
will not contribute to network plots. The argument defaults to 0.05.}
}
\value{
A data.table where the first four columns represent SNPs and the fifth column (edge.score)
is the graphical SNP-pair score.
}
\description{
This function returns a data.table of graphical SNP-pair scores for use in network plots of GADGETS results.
}
\examples{

data(case)
data(dad)
data(mom)
data(snp.annotations)
library(Matrix)
set.seed(1400)
block.ld.mat <- as.matrix(bdiag(list(matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25))))

#preprocess data
target.snps <- c(1:3, 30:32, 60:62, 85)
pp.list <- preprocess.genetic.data(case[, target.snps], father.genetic.data = dad[ , target.snps],
                               mother.genetic.data = mom[ , target.snps],
                               block.ld.mat = block.ld.mat[target.snps , target.snps])
## run GA for observed data

#observed data chromosome size 2
run.gadgets(pp.list, n.chromosomes = 5, chromosome.size = 2, results.dir = 'tmp_2',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 combined.res2 <- combine.islands('tmp_2', snp.annotations[ target.snps, ], pp.list)
 unlink('tmp_reg', recursive = TRUE)

 #observed data chromosome size 3
 run.gadgets(pp.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'tmp_3',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 combined.res3 <- combine.islands('tmp_3', snp.annotations[ target.snps, ], pp.list)
 unlink('tmp_reg', recursive = TRUE)

 ## create list of results

 final.results <- list(combined.res2[1:3, ], combined.res3[1:3, ])

 ## compute edge scores
 edge.dt <- compute.pair.scores(final.results, pp.list, 3, pval.thresh = 1)

 lapply(c('tmp_2', 'tmp_3'), unlink, recursive = TRUE)

}
