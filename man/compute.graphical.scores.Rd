% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute.graphical.scores.R
\name{compute.graphical.scores}
\alias{compute.graphical.scores}
\title{A function to compute SNP-pair scores for network plots of results.}
\usage{
compute.graphical.scores(
  results.list,
  pp.list,
  score.type = "logsum",
  pval.thresh = 0.05,
  n.permutes = 10000,
  n.different.snps.weight = 2,
  n.both.one.weight = 1,
  weight.function.int = 2,
  recessive.ref.prop = 0.75,
  recode.test.stat = 1.64,
  dif.coding = FALSE,
  bp.param = bpparam()
)
}
\arguments{
\item{results.list}{A list of length d, where d is the number of chromosome
sizes to be included in the network plot.
 Each element of the list must be a data.table from \code{combine.islands}
 for a given chromosome size.
 Each data.table in the list should be subset to the top \code{n.top.scores}
 scores,
 otherwise an error will be returned.}

\item{pp.list}{The list output by \code{preprocess.genetic.data} run on the
observed data.}

\item{score.type}{A character string specifying the method for aggregating
SNP-pair scores across chromosome sizes. Options are
'max', 'sum', or 'logsum', defaulting to "logsum". For a given SNP-pair,
it's graphical score will be the \code{score.type} of all
graphical scores of chromosomes containing that pair across chromosome sizes.
 The choice of 'logsum' rather than 'sum'
may be useful in cases where there are multiple risk-sets, and one is found
much more frequently. However, it may be of interest to examine
plots using both \code{score.type} approaches. Note that "logsum" is
actually the log of one plus the sum of the SNP-pair scores to avoid nodes or
edges having negative weights.}

\item{pval.thresh}{A numeric value between 0 and 1 specifying the epistasis
test p-value threshold for a
chromosome to contribute to the network. Any chromosomes with epistasis
p-value greater than \code{pval.thresh}
will not contribute to network plots. The argument defaults to 0.05.
It must be <= 0.6 (to ensure positive scores).}

\item{n.permutes}{The number of permutations on which to base the epistasis
tests. Defaults to 10000.}

\item{n.different.snps.weight}{The number by which the number of
different SNPs between a case and complement/unaffected sibling
is multiplied in computing the family weights. Defaults to 2.}

\item{n.both.one.weight}{The number by which the number of SNPs equal
 to 1 in both the case and complement/unaffected sibling
is multiplied in computing the family weights. Defaults to 1.}

\item{weight.function.int}{An integer used to assign family weights.
Specifically, we use \code{weight.function.int} in a function that takes
 the weighted sum
of the number of different SNPs and SNPs both equal to one as an argument,
denoted as x, and
returns a family weight equal to \code{weight.function.int}^x. Defaults to 2.}

\item{recessive.ref.prop}{The proportion to which the observed proportion of
 informative cases with the provisional risk genotype(s) will be compared
to determine whether to recode the SNP as recessive. Defaults to 0.75.}

\item{recode.test.stat}{For a given SNP, the minimum test statistic required
 to recode and recompute the fitness score using recessive coding. Defaults
 to 1.64.
See the GADGETS paper for specific details.}

\item{dif.coding}{A logical indicating whether, for a given SNP, the case -
complement genotype difference should
be coded as the sign of the difference (defaulting to false) or the raw
difference.}

\item{bp.param}{The BPPARAM argument to be passed to bplapply. See
\code{BiocParallel::bplapply} for more details.}
}
\value{
A list of two elements:
\describe{
 \item{pair.scores}{A data.table containing SNP-pair graphical scores,
 where the first four columns represent SNPs and the fifth column
 (pair.score)
is the graphical SNP-pair score.}
 \item{snp.scores}{A data.table containing individual SNP graphical scores,
 where the first two columns represent SNPs and the third column (snp.score)
is the graphical SNP score.}
}
}
\description{
This function returns a data.table of graphical SNP-pair scores for use in
 network plots of GADGETS results.
}
\examples{

data(case)
data(dad)
data(mom)
data(snp.annotations)
library(Matrix)
set.seed(1400)
block.ld.mat <- as.matrix(bdiag(list(
    matrix(rep(TRUE, 25^2), nrow = 25),
    matrix(rep(TRUE, 25^2), nrow = 25),
    matrix(rep(TRUE, 25^2), nrow = 25),
    matrix(rep(TRUE, 25^2), nrow = 25)
)))

# preprocess data
target.snps <- c(1:3, 30:32, 60:62, 85)
pp.list <- preprocess.genetic.data(case[, target.snps],
    father.genetic.data = dad[, target.snps],
    mother.genetic.data = mom[, target.snps],
    block.ld.mat = block.ld.mat[target.snps, target.snps]
)
## run GA for observed data

# observed data chromosome size 2
run.gadgets(pp.list,
    n.chromosomes = 5, chromosome.size = 2, results.dir = "tmp_2",
    cluster.type = "interactive", registryargs = list(
        file.dir = "tmp_reg",
        seed = 1500
    ),
    generations = 2, n.islands = 2, island.cluster.size = 1,
    n.migrations = 0
)
combined.res2 <- combine.islands(
    "tmp_2", snp.annotations[target.snps, ],
    pp.list, 2
)
unlink("tmp_reg", recursive = TRUE)

# observed data chromosome size 3
run.gadgets(pp.list,
    n.chromosomes = 5, chromosome.size = 3, results.dir = "tmp_3",
    cluster.type = "interactive", registryargs = list(
        file.dir = "tmp_reg",
        seed = 1500
    ),
    generations = 2, n.islands = 2, island.cluster.size = 1,
    n.migrations = 0
)
combined.res3 <- combine.islands(
    "tmp_3", snp.annotations[target.snps, ],
    pp.list, 2
)
unlink("tmp_reg", recursive = TRUE)

## create list of results

final.results <- list(combined.res2[1:3, ], combined.res3[1:3, ])

## compute edge scores
edge.dt <- compute.graphical.scores(final.results, pp.list,
    pval.thresh = 0.5
)

lapply(c("tmp_2", "tmp_3"), unlink, recursive = TRUE)

}
