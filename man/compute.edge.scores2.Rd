% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute.edge.scores2.R
\name{compute.edge.scores2}
\alias{compute.edge.scores2}
\title{A function to compute edge scores for network plots of results.}
\usage{
compute.edge.scores2(
  results.list,
  pp.list,
  n.top.chroms = 50,
  score.type = "logsum",
  epi.test.permutes = 100,
  bp.param = SerialParam()
)
}
\arguments{
\item{results.list}{A list of length d, where d is the number of chromosome sizes to be included in the network plot.
Each element of the list must itself be a list whose first element \code{observed.data} is a vector of fitness scores from the
the \code{unique.results} chromosome results from \code{combine.islands} for a given chromosome size. The second element \code{permutation.list}
is a list containing vectors of all permutation results fitness scores, again using the \code{unique.results} results output by
\code{combine.islands} for each permutation. Each data.table in the list should be subset to the top \code{n.top.scores} scores,
otherwise an error will be returned.}

\item{pp.list}{The list output by \code{preprocess.genetic.data} run on the observed data.}

\item{score.type}{A character string specifying the method for scoring edges, with options
'max', 'sum', or 'logsum'. The default is 'max', but 'logsum' may also be particularly useful.
 Note that "logsum" is actually the log of one plus the sum of the fitness scores to avoid nodes or edges having negative
 weights.}

\item{epi.test.permutes}{The number of permutes used to compute the epistasis test p-values.}

\item{bp.param}{The \code{bp.param} argument to be passed to \code{run.epi.test}.
If using a cluster computer, this parameter needs to be set with care. See \code{BiocParallel::bplapply} for more details}

\item{n.top.scores}{The number of top scoring chromosomes to be used in calculating the edge.scores. Defaults to 50.}
}
\value{
A data.table where the first two columns represent SNPs and the third column (edge.score)
is the edge score of a chromosome containing those SNPs.
}
\description{
This function returns a data.table of edge weights for use in network plots of GA results.
}
\examples{

data(case)
data(dad)
data(mom)
data(snp.annotations)
library(Matrix)
set.seed(1400)
block.ld.mat <- as.matrix(bdiag(list(matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25))))

pp.list <- preprocess.genetic.data(case[, 1:10], father.genetic.data = dad[ , 1:10],
                               mother.genetic.data = mom[ , 1:10],
                               block.ld.mat = block.ld.mat[ , 1:10])
## run GA for observed data

#observed data chromosome size 2
run.ga(pp.list, n.chromosomes = 5, chromosome.size = 2, results.dir = 'tmp_2',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 combined.res2 <- combine.islands('tmp_2', snp.annotations[ 1:10, ], pp.list)
 unlink('tmp_reg', recursive = TRUE)

 #observed data chromosome size 3
 run.ga(pp.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'tmp_3',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 combined.res3 <- combine.islands('tmp_3', snp.annotations[ 1:10, ], pp.list)
 unlink('tmp_reg', recursive = TRUE)

#create three permuted datasets
set.seed(1400)
perm.data.list <- permute.dataset(case[ , 1:10],
                                  father.genetic.data = dad[ , 1:10],
                                  mother.genetic.data = mom[ , 1:10],
                                  n.permutations = 3)

#pre-process permuted data
p1.list <- preprocess.genetic.data(perm.data.list[['permutation1']]$case,
                                   complement.genetic.data = perm.data.list[['permutation1']]$comp,
                                   block.ld.mat = block.ld.mat[ , 1:10])

p2.list <- preprocess.genetic.data(perm.data.list[['permutation2']]$case,
                                   complement.genetic.data = perm.data.list[['permutation2']]$comp,
                                   block.ld.mat = block.ld.mat[ , 1:10])

p3.list <- preprocess.genetic.data(perm.data.list[['permutation3']]$case,
                                   complement.genetic.data = perm.data.list[['permutation3']]$comp,
                                   block.ld.mat = block.ld.mat[ , 1:10])

##run GA for permuted data

#permutation 1, chromosome size 2
run.ga(p1.list, n.chromosomes = 5, chromosome.size = 2, results.dir = 'p1_tmp_2',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 p1.combined.res2 <- combine.islands('p1_tmp_2', snp.annotations[ 1:10, ], p1.list)
 unlink('tmp_reg', recursive = TRUE)

#permutation 1, chromosome size 3
run.ga(p1.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'p1_tmp_3',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 p1.combined.res3 <- combine.islands('p1_tmp_3', snp.annotations[ 1:10, ], p1.list)
 unlink('tmp_reg', recursive = TRUE)

#permutation 2, chromosome size 2
run.ga(p2.list, n.chromosomes = 5, chromosome.size = 2, results.dir = 'p2_tmp_2',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 p2.combined.res2 <- combine.islands('p2_tmp_2', snp.annotations[ 1:10, ], p2.list)
 unlink('tmp_reg', recursive = TRUE)

#permutation 2, chromosome size 3
run.ga(p2.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'p2_tmp_3',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 p2.combined.res3 <- combine.islands('p2_tmp_3', snp.annotations[ 1:10, ], p2.list)
 unlink('tmp_reg', recursive = TRUE)

#permutation 3, chromosome size 2
run.ga(p3.list, n.chromosomes = 5, chromosome.size = 2, results.dir = 'p3_tmp_2',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 p3.combined.res2 <- combine.islands('p3_tmp_2', snp.annotations[ 1:10, ], p3.list)
 unlink('tmp_reg', recursive = TRUE)

#permutation 3, chromosome size 3
run.ga(p3.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'p3_tmp_3',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 p3.combined.res3 <- combine.islands('p3_tmp_3', snp.annotations[ 1:10, ], p3.list)
 unlink('tmp_reg', recursive = TRUE)

 ## create list of results

 #chromosome size 2 results
 chrom2.list <- list(observed.data = combined.res2$unique.results[1:3, ],
                    permutation.list = list(p1.combined.res2$unique.results[1:3, ],
                                            p2.combined.res2$unique.results[1:3, ],
                                            p3.combined.res2$unique.results[1:3, ]))

 #chromosome size 3 results
 chrom3.list <- list(observed.data = combined.res3$unique.results[1:3, ],
                    permutation.list = list(p1.combined.res3$unique.results[1:3, ],
                                            p2.combined.res3$unique.results[1:3, ],
                                            p3.combined.res3$unique.results[1:3, ]))

 final.results <- list(chrom2.list, chrom3.list)

 ## compute edge scores
 edge.dt <- compute.edge.scores2(final.results, pp.list, 3)

 lapply(c('tmp_2', 'tmp_3', 'p1_tmp_2', 'p2_tmp_2', 'p3_tmp_2',
          'p1_tmp_3', 'p2_tmp_3', 'p3_tmp_3'), unlink, recursive = TRUE)

}
