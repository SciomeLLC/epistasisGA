% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute.edge.scores2.R
\name{compute.edge.scores2}
\alias{compute.edge.scores2}
\title{A function to compute edge scores for network plots of results.}
\usage{
compute.edge.scores2(
  results.list,
  pp.list,
  n.top.chroms = 50,
  score.type = "logsum",
  epi.test.permutes = 100,
  bp.param = SerialParam()
)
}
\arguments{
\item{results.list}{A list of length d, where d is the number of chromosome sizes to be included in the network plot.
Each element of the list must be a data.table from the \code{unique.results} chromosome results from \code{combine.islands} for a given chromosome size.
Each data.table in the list should be subset to the top \code{n.top.scores} scores,
otherwise an error will be returned.}

\item{pp.list}{The list output by \code{preprocess.genetic.data} run on the observed data.}

\item{score.type}{A character string specifying the method for scoring edges, with options
'max', 'sum', or 'logsum'. The default is 'max', but 'logsum' may also be particularly useful.
 Note that "logsum" is actually the log of one plus the sum of the fitness scores to avoid nodes or edges having negative
 weights.}

\item{epi.test.permutes}{The number of permutes used to compute the epistasis test p-values.}

\item{bp.param}{The \code{bp.param} argument to be passed to \code{run.epi.test}.
If using a cluster computer, this parameter needs to be set with care. See \code{BiocParallel::bplapply} for more details}

\item{n.top.scores}{The number of top scoring chromosomes to be used in calculating the edge.scores. Defaults to 50.}
}
\value{
A data.table where the first four columns represent SNPs and the fifth column (edge.score)
is the edge score of a chromosome containing those SNPs.
}
\description{
This function returns a data.table of edge weights for use in network plots of GA results.
}
\examples{

data(case)
data(dad)
data(mom)
data(snp.annotations)
library(Matrix)
set.seed(1400)
block.ld.mat <- as.matrix(bdiag(list(matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25),
                              matrix(rep(TRUE, 25^2), nrow = 25))))

#preprocess data
target.snps <- c(1:3, 30:32, 60:62, 85)
pp.list <- preprocess.genetic.data(case[, target.snps], father.genetic.data = dad[ , target.snps],
                               mother.genetic.data = mom[ , target.snps],
                               block.ld.mat = block.ld.mat[target.snps , target.snps])
## run GA for observed data

#observed data chromosome size 2
run.ga(pp.list, n.chromosomes = 5, chromosome.size = 2, results.dir = 'tmp_2',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 combined.res2 <- combine.islands('tmp_2', snp.annotations[ target.snps, ], pp.list)
 unlink('tmp_reg', recursive = TRUE)

 #observed data chromosome size 3
 run.ga(pp.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'tmp_3',
       cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
       generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
 combined.res3 <- combine.islands('tmp_3', snp.annotations[ target.snps, ], pp.list)
 unlink('tmp_reg', recursive = TRUE)

 ## create list of results

 final.results <- list(combined.res2$unique.results[1:3, ], combined.res3$unique.results[1:3, ])

 ## compute edge scores
 edge.dt <- compute.edge.scores2(final.results, pp.list, 3)

 lapply(c('tmp_2', 'tmp_3', 'p1_tmp_2', 'p2_tmp_2', 'p3_tmp_2',
          'p1_tmp_3', 'p2_tmp_3', 'p3_tmp_3'), unlink, recursive = TRUE)

}
