#' A function to identify a SNPs to be included in a network plot
#'
#' This function compares the edge scores generated by \code{compute.edge.scores} in the observed data to a list of permuted
#' null datasets and identifies SNPs to be included in a network plot. Specifically, it finds a threshold edge.score, t, such that the mean
#' fraction of edge scores exceeding t over all permuted datasets divided by the fraction of edge scores exceeding t in the observed data is
#' not greater than a desired threshold. We refer to this ratio as the rFDR.
#'
#' @param observed.edges The data.table output from \code{compute.edge.scores} run on the observed data.
#' @param permutation.edges.list A list of data.tables, each containing the result for \code{compute.edge.scores} run on the results of a permutation dataset.
#' @param desired.rFDR The desired rFDR threshold. Defaults to 0.01.
#' @return a list containing the following:
#' \describe{
#'  \item{network.edges}{A data.table of network edges, where the first two columns represent SNPs and the third column (edge.score)
#'  is the edge score of a chromosome containing those SNPs, where the edge.scores exceed a threshold, t, such that the achieved rFDR
#'  is not greater than \code{desired.rFDR}.}
#'  \item{rFDR}{The achieved rFDR.}
#'  \item{t}{The threshold edge.score, t, corresponding to the achieved rFDR.}
#' }
#' @examples
#' data(case)
#' data(dad)
#' data(mom)
#' data(snp.annotations)
#' library(Matrix)
#' chrom.mat <- as.matrix(bdiag(list(matrix(rep(TRUE, 25^2), nrow = 25),
#'                               matrix(rep(TRUE, 25^2), nrow = 25),
#'                               matrix(rep(TRUE, 25^2), nrow = 25),
#'                               matrix(rep(TRUE, 25^2), nrow = 25))))
#'
# ## preprocess data
#' pp.list <- preprocess.genetic.data(case[, 1:10], father.genetic.data = dad[ , 1:10],
#'                                mother.genetic.data = mom[ , 1:10],
#'                                chrom.mat = chrom.mat[ , 1:10])
#' ## run GA for observed data
#'
#' run.ga(pp.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'tmp_3',
#'        cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
#'        generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
#'  combined.res3 <- combine.islands('tmp_3', snp.annotations[ 1:10, ], pp.list)
#'  unlink('tmp_reg', recursive = TRUE)
#'
#' ## create three permuted datasets
#' set.seed(1400)
#' perm.data.list <- permute.dataset(case[ , 1:10],
#'                                   father.genetic.data = dad[ , 1:10],
#'                                   mother.genetic.data = mom[ , 1:10],
#'                                   n.permutations = 3)
#'
#' ## pre-process permuted data
#' p1.list <- preprocess.genetic.data(perm.data.list[['permutation1']]$case,
#'                                    complement.genetic.data = perm.data.list[['permutation1']]$comp,
#'                                    chrom.mat = chrom.mat[ , 1:10])
#'
#' p2.list <- preprocess.genetic.data(perm.data.list[['permutation2']]$case,
#'                                    complement.genetic.data = perm.data.list[['permutation2']]$comp,
#'                                    chrom.mat = chrom.mat[ , 1:10])
#'
#' p3.list <- preprocess.genetic.data(perm.data.list[['permutation3']]$case,
#'                                    complement.genetic.data = perm.data.list[['permutation3']]$comp,
#'                                    chrom.mat = chrom.mat[ , 1:10])
#'
#' ## run GA for permuted data
#'
#' run.ga(p1.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'p1_tmp_3',
#'        cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
#'        generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
#'  p1.combined.res3 <- combine.islands('p1_tmp_3', snp.annotations[ 1:10, ], p1.list)
#'  unlink('tmp_reg', recursive = TRUE)
#'
#' run.ga(p2.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'p2_tmp_3',
#'        cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
#'        generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
#'  p2.combined.res3 <- combine.islands('p2_tmp_3', snp.annotations[ 1:10, ], p2.list)
#'  unlink('tmp_reg', recursive = TRUE)
#'
#' run.ga(p3.list, n.chromosomes = 5, chromosome.size = 3, results.dir = 'p3_tmp_3',
#'        cluster.type = 'interactive', registryargs = list(file.dir = 'tmp_reg', seed = 1500),
#'        generations = 2, n.islands = 2, island.cluster.size = 1, n.top.chroms = 3)
#'  p3.combined.res3 <- combine.islands('p3_tmp_3', snp.annotations[ 1:10, ], p3.list)
#'  unlink('tmp_reg', recursive = TRUE)
#'
#'  #get edge scores
#'  obs.edge.scores <- compute.edge.scores(combined.res3$unique.results)
#'  perm.edge.scores <- lapply(list(p1.combined.res3$unique.results,
#'                         p2.combined.res3$unique.results,
#'                         p3.combined.res3$unique.results), compute.edge.scores)
#'
#'  ## get thresholded edge scores
#'  threshold.res <- network.threshold(obs.edge.scores,
#'                    perm.edge.scores)
#'
#'  ## plot thresholded network
#'  network.plot(edge.dt = threshold.res$network.edges)
#'
#'  lapply(c('tmp_3' ,'p1_tmp_3', 'p2_tmp_3', 'p3_tmp_3'), unlink, recursive = TRUE)
#'
#' @importFrom data.table rbindlist
#' @importFrom stats quantile
#' @export

network.threshold <- function(observed.edges, permutation.edges.list, desired.rFDR = 0.01) {

    # grab observed edge scores
    n.obs.edges <- nrow(observed.edges)
    obs.edge.scores <- sort(unique(observed.edges$edge.score), decreasing = TRUE)

    # initialize threshold value based on the observed data
    tval <- quantile(obs.edge.scores, 1 - desired.rFDR, type = 4)
    obs.prop.higher <- sum(observed.edges$edge.score >= tval)/n.obs.edges

    # find the closest edge scores above and below the threshold value
    higher.scores.idx <- obs.edge.scores >= tval
    lower.scores.idx <- obs.edge.scores < tval
    closest.hi <- which(higher.scores.idx)[which.min(obs.edge.scores[higher.scores.idx] - tval)]
    closest.low <- which(lower.scores.idx)[which.max(obs.edge.scores[lower.scores.idx] - tval)]

    # compute proportion higher than the tval in the permuted datasets
    perm.prop.higher <- vapply(permutation.edges.list, function(x){

        sum(x$edge.score >= tval)/nrow(x)

    }, 1.0)
    mean.perm.prop.higher <- mean(perm.prop.higher)
    perm.obs.ratio <- mean.perm.prop.higher/obs.prop.higher

    # if we hi the correct threshold, stop, otherwise keep looking
    if (perm.obs.ratio == desired.rFDR){

        network.edges <- observed.edges[observed.edges$edge.score >= tval, ]
        rFDR <- perm.obs.ratio
        return(list(network.edges = network.edges, rFDR = rFDR, edge.score.threshold = tval))

    } else {

        # if we have too high of a ratio, increase the the threshold score value
        if (perm.obs.ratio > desired.rFDR){

            top <- FALSE
            i <- closest.hi
            while (perm.obs.ratio > desired.rFDR & i >= 1){

                tval <- obs.edge.scores[i]
                obs.prop.higher <- sum(observed.edges$edge.score >= tval)/n.obs.edges
                perm.prop.higher <- vapply(permutation.edges.list, function(x){

                    sum(x$edge.score >= tval)/nrow(x)

                }, 1.0)
                mean.perm.prop.higher <- mean(perm.prop.higher)
                perm.obs.ratio <- mean.perm.prop.higher/obs.prop.higher

                # increment iterator
                # since the vector is sorted in decreasing order, we
                # decrease the iterator to increase the threshold val
                i <- i - 1

            }

            # once we find a threshold that produces a rFDR <= desired level, return the result
            network.edges <- observed.edges[observed.edges$edge.score >= tval, ]
            rFDR <- perm.obs.ratio
            return(list(network.edges = network.edges, rFDR = rFDR, edge.score.threshold = tval))

        # if we have too low of a ratio, decrease the threshold score value
        } else if (perm.obs.ratio < desired.rFDR){

            type <- "low"
            i <- closest.low
            while (perm.obs.ratio < desired.rFDR & i <= length(obs.edge.scores)){

                tval <- obs.edge.scores[i]
                obs.prop.higher <- sum(observed.edges$edge.score >= tval)/n.obs.edges
                perm.prop.higher <- vapply(permutation.edges.list, function(x){

                    sum(x$edge.score >= tval)/nrow(x)

                }, 1.0)
                mean.perm.prop.higher <- mean(perm.prop.higher)
                perm.obs.ratio <- mean.perm.prop.higher/obs.prop.higher

                # increment iterator
                # since the vector is sorted in decreasing order, we
                # decrease the iterator to increase the threshold val
                i <- i + 1

            }

            # once we find a threshold that produces a rFDR >= desired level, return the result
            # if precisely equal to the desired threshold, no further work is needed
            if (perm.obs.ratio == desired.rFDR){

                network.edges <- observed.edges[observed.edges$edge.score >= tval, ]
                rFDR <- perm.obs.ratio
                return(list(network.edges = network.edges, rFDR = rFDR, edge.score.threshold = tval))

            # if not precisely equal and the perm.obs.ratio now exceeds the desired threshold, then go
            # back one step in the index
            } else{

                message("Exact desired threshold could not be achieved, returning closest value <= desired rFDR.")
                if (type == "low"){

                    # if we don't actually find the value such that the perm.obs.ratio switches from lt
                    # threshold value to gt desired.rFDR, choose the lowest obs.edge score
                    if (perm.obs.ratio < desired.rFDR){

                        tval <- obs.edge.scores[i - 1]

                    # otherwise, choose the obs.edge.score that is the lowest without having perm.obs.ratio
                    # exceed the desired threshold
                    } else {

                        tval <- obs.edge.scores[i - 2]

                    }

                } else if (type == "high"){

                    tval <- obs.edge.scores[i + 1]

                }

                obs.prop.higher <- sum(observed.edges$edge.score >= tval)/n.obs.edges
                perm.prop.higher <- vapply(permutation.edges.list, function(x){

                    sum(x$edge.score >= tval)/nrow(x)

                }, 1.0)
                mean.perm.prop.higher <- mean(perm.prop.higher)
                perm.obs.ratio <- mean.perm.prop.higher/obs.prop.higher
                network.edges <- observed.edges[observed.edges$edge.score >= tval, ]
                rFDR <- perm.obs.ratio
                return(list(network.edges = network.edges, rFDR = rFDR, t = tval))

            }

        }

    }

}


